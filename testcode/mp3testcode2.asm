ORIGIN 4x0000
SEGMENT
CodeSegment:
;;TEST ADD NOT AND
	AND R0, R0, 0
	ADD R1, R0, 5
	NOT R1, R1
	ADD R2, R2, 7
	AND R3, R1, R2
	AND R4, R3, 3
;;INITIALIZE REGISTERS
	AND R0, R0, 0
	AND R1, R0, 0
	AND R2, R0, 0
	AND R3, R0, 0
	AND R4, R0, 0
	AND R5, R0, 0
	AND R6, R0, 0
	AND R7, R0, 0

;;TEST JMP
	LEA R2, TEST_JMP
	JMP R2
	LDR R1, R0, BAD	;TEST JMP WORKS
 			;IF JMP WORKS, THIS LINE WILL NOT RUN 


TEST_JMP: 
	LEA R0, DataSegment 	
	LDR R3, R0, TMP_VAL 	; TEST LDR
	JSR TEST_JSR		; TEST JSR
;;TEST SHF
	RSHFL R1, R1, 1 	; R1 <= 600d >> 1 
	LSHF R5, R1, 1 		; R5 <= 600c
	RSHFA R6, R1, 5		; R6 <= R1 >> 5
;;TEST JSSR	
	LEA R6, TEST_JSRR 	
	JSRR R6 		; CALL TEST_JSSR

	BRnzp HALT

TEST_JSR:
;; TEST_JSR ALSO TESTS LDR AND STR
;; ALSO TESTS STI AND LDI
	LDR R2, R0, GOOD		; JUDGE WHETHER JUMP TO TEST_JSR
	LEA R3, TAR1			; R3 HAS ADDRESS TO STORE
	STR R2, R0, TAR1 		; TAR1 SHOULD STORE GOOD
	LDR R3, R0, TAR1		; R3 SHOULD BE GOOD
	LEA R1, TAR3 			; R1 RECORDS THE ADDRESS OF TAR3
	STR R1, R0, TAR1		; [TAR1] = ADDR OF TAR3 
	LDR R2, R0, TAR1 		; (R2 == R1) SHOULD BE TRUE
	STI R3, R0, TAR1 		; [TAR3] = GOOD SHOULD BE TRUE
	ADD R5, R5, R3			; RECORD R3
	LDR R1, R0, TAR3 		; R1 <= GOOD 
	LEA R5, TAR3 			; R5 <= ADDR OF TAR3
	LDI R2, R0, TAR1		; R2 <= GOOD
	RET

TEST_JSRR:
;; TEST LDB AND STB
	LDB R4, R0, LEET 	; R4 <= 0016
	LEA R1, DataSegment 	
	ADD R1, R1, 1 		; ADD 1
 	LDB R5, R1, LEET 	; R5 <= 0020

 	LEA R3, TAR3
 	AND R6, R6, 0 		; R6 <= 0 
 	STR R6, R0, TAR3 	; TAR3 = 0
 	LDR R4, R0, AB 		; R4 = AB
 	LDR R2, R0, CD 		; R2 = CD

 	STB R4, R0, TAR3 	; TAR3 <= x00AB
 	LDR R6, R0, TAR3 	; R6 <= x00AB 
 	STB R2, R1, TAR3 	; TAR3 <= xCDAB
 	LDR R5, R0, TAR3 	; R5 <= XCDAB 


	RET

HALT:
	BRnzp HALT

SEGMENT DataSegment:   
TMP_VAL: DATA2 4x0001   
BAD: DATA2 4x0bad    
GOOD: DATA2 4x600D    
LEET: DATA2 4x2016 	 
AB: DATA2 4x00AB
CD: DATA2 4x00CD
TAR1: DATA2 0
TAR2: DATA2 0
TAR3: DATA2 0
